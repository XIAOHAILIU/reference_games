///fold:
var softplus = function(x) {
    return Math.log(Math.exp(x) + 1);
};

var getTrajectories = function(data) {
  var keys = _.keys(data[0]);
  return reduce(function(key, memo) {
    var timeBasedKeys = map(function(i) {return key + "." + i;}, _.range(data.length));
    var vals = _.map(data, key);
    return extend(_.zipObject(timeBasedKeys, vals), memo);
  }, [], keys);
};
///

// possible states of the world
var states = ['t1', 't2'];
var statePrior =  Categorical({vs: states, ps: [1/2, 1/2]});

// possible utterances
var utterances = ['label1', 'label2'];
var utterancePrior = Categorical({vs: utterances, ps: [1/2, 1/2]});

var params = {
  alpha: 5,
  beta: 1,
  numSteps: 3
};

// takes a sample from a dirichlet distribution for each word,
// representing the extent to which that word describes each object
var lexiconPrior = function(){
  var meanings = map(function(utt) {
    var t1Prob = sample(Beta({a: 1, b: 1}), {
      guide () {
	return Beta({a: softplus(param({name: 'beta_a_' + utt + globalStore.originAgent})),
		     b: softplus(param({name: 'beta_b_' + utt + globalStore.originAgent}))});
      }
    });
    return {'t1' : t1Prob, 't2' : 1-t1Prob};
  }, utterances);
  return _.zipObject(utterances, meanings);
};

// length-based cost (although they're all the same length here)
var uttCost = function(utt) {
  return utt.split(' ').length;
};

// literal listener (using real-valued lexicon)
var L0 = function(utt, lexicon) {
  return Infer({method:"enumerate"}, function(){
    var state = sample(statePrior);
    factor(Math.log(lexicon[utt][state]));
    return state;
  });
};

// pragmatic speaker 
var S1 = function(state, lexicon) {
  return Infer({method:"enumerate"}, function(){
    var utt = sample(utterancePrior);
    factor(params.alpha * (L0(utt, lexicon).score(state))
           - params.beta * uttCost(utt));
    return utt;
  });
};

// conventional listener
var L1 = function(utt, lexicon) {
  return Infer({method:"enumerate"}, function(){
    var state = sample(statePrior);
    observe(S1(state, lexicon), utt);
    return state;
  });
};

// TODO: this is redoing a lot of work... It'd be nicer if we could update only on
// the new datapoint rather than having to go back over the whole history every time...
// seems like andreas's param store could come in handy here.
var lexiconModel = function() {
  var lexicon = lexiconPrior();
  mapData({data: globalStore.data}, function(datum){
    if(globalStore.originAgent == 'L')
      observe(S1(datum.response, lexicon), datum['utt']);
    else if(globalStore.originAgent == 'S')
      observe(L1(datum.utt, lexicon), datum['response']);
  });
  return lexicon;
};

// compute lexicon posterior, taking into account some previous observations
// speakers do this by assuming data came from knowledgable listener, and vice versa
var marginalizedL1 = cache(function(originAgent, utt, data) {
  globalStore.data = data;
  globalStore.originAgent = originAgent;

  Optimize({model: lexiconModel,
	    method: 'optimize', steps: 1000, verbose: false,
	    optMethod: {adam: {stepSize: .1}}});

  return Infer({method: 'forward', samples: 250, guide: true, model: function() {
    var dist = L1(utt, lexiconModel());
    return sample(dist, {guide() {return dist;}});
  }});
});

// conventional listener (L1, marginalizing over lexicons)
var L = cache(function(utt, data) {
  return marginalizedL1('L', utt, data);
});

// conventional speaker (S1, reasoning about expected L1 behavior across lexicons)
var S = cache(function(state, data) {
  return Infer({method: 'enumerate'}, function(){
    var utt = sample(utterancePrior);
    var listener = marginalizedL1('S', utt, data);
    factor(params.alpha * listener.score(state)
           - params.beta * uttCost(utt));
    return utt;
  });
});

var model = function() {
  console.log('sampling...');
  setFreshParamsId();
  var step = function(data) {
    if(data.length > params.numSteps) return getTrajectories(data);
    var state = sample(statePrior);
    var utt = sample(S(state, data));
    var response = sample(L(utt, data));
    var newDatum = {utt, response, intended: state, acc: state == response};
    return step(data.concat(newDatum));
  };
  step([]);
};
